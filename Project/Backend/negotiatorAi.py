import os
import asyncio
import re
import subprocess
from dotenv import load_dotenv
from portia import Config, LLMProvider, Portia
import httpx
from bs4 import BeautifulSoup
from telegram import Bot

# Load environment variables
load_dotenv()

GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID')
MCP_EMAIL_SERVER_PATH = "./email-mcp-server"  # Fixed path

# Initialize Telegram Bot
telegram_bot = Bot(token=TELEGRAM_BOT_TOKEN)

# --------------------------
# MCP Email Integration (FIXED)
# --------------------------
class MCPEmailClient:
    def __init__(self, server_path):
        self.server_path = server_path
    
    async def send_email_via_mcp(self, recipient, subject, body):
        """Send email using the MCP server's functionality"""
        try:
            # Change to MCP server directory and run
            current_dir = os.getcwd()
            os.chdir(self.server_path)
            
            # Create HTML formatted email body
            html_body = f"""
            <html>
              <head></head>
              <body>
                <h2>ü§ñ NegotiatorAI Generated Message</h2>
                <div style="background-color: #f0f0f0; padding: 15px; border-radius: 5px; margin: 10px 0;">
                    <pre style="white-space: pre-wrap; font-family: Arial, sans-serif;">{body}</pre>
                </div>
                <p><small>Generated by NegotiatorAI - Your AI Negotiation Assistant</small></p>
              </body>
            </html>
            """
            
            # Write the email script to a temporary file to avoid quote issues
            email_script = f'''
import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from dotenv import load_dotenv

load_dotenv()

msg = MIMEMultipart("alternative")
msg["Subject"] = """{subject}"""
msg["From"] = os.getenv("EMAIL_USER")
msg["To"] = """{recipient}"""

body_text = """{body}"""
html_text = """{html_body}"""

text_part = MIMEText(body_text, "plain")
html_part = MIMEText(html_text, "html")

msg.attach(text_part)
msg.attach(html_part)

with smtplib.SMTP(os.getenv("SMTP_SERVER"), int(os.getenv("SMTP_PORT"))) as server:
    server.starttls()
    server.login(os.getenv("EMAIL_USER"), os.getenv("EMAIL_PASS"))
    server.send_message(msg)
print("Email sent successfully!")
'''
            
            # Write script to temporary file
            with open("temp_email_script.py", "w") as f:
                f.write(email_script)
            
            # Run the script
            cmd = ["poetry", "run", "python", "temp_email_script.py"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # Clean up
            if os.path.exists("temp_email_script.py"):
                os.remove("temp_email_script.py")
            os.chdir(current_dir)
            
            if result.returncode == 0:
                print("‚úÖ Email sent successfully via MCP server!")
                return True
            else:
                print(f"‚ùå MCP Email error: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"‚ùå MCP Email send failed: {e}")
            if 'current_dir' in locals():
                os.chdir(current_dir)
            return False

# --------------------------
# Utility: Extract numeric price from string
# --------------------------
def extract_numeric_price(price_str):
    price_str = price_str.replace(',', '')
    match = re.search(r'[\d.]+', price_str)
    if match:
        return float(match.group())
    return None

# --------------------------
# Suggest negotiation price
# --------------------------
def suggest_price(listed_price, competitor_prices):
    if competitor_prices:
        prices = []
        for item in competitor_prices:
            p = extract_numeric_price(item['price'])
            if p is not None:
                prices.append(p)
        if prices:
            avg_price = sum(prices) / len(prices)
            suggested = max(avg_price, listed_price * 0.85)
        else:
            suggested = listed_price * 0.85
    else:
        suggested = listed_price * 0.85
    return round(suggested, 2)

# --------------------------
# Web scraper for competitor prices
# --------------------------
async def scrape_ebay(search_term):
    url = f"https://www.ebay.com/sch/i.html?_nkw={search_term.replace(' ', '+')}"
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url)
        soup = BeautifulSoup(response.text, "html.parser")
        results = []
        listings = soup.select('li.s-item')
        for item in listings[:5]:
            title = item.select_one('h3.s-item__title')
            price = item.select_one('.s-item__price')
            if title and price:
                results.append({"title": title.text.strip(), "price": price.text.strip()})
        return results
    except Exception as e:
        print(f"Error scraping eBay: {e}")
        return []

# --------------------------
# Telegram send message
# --------------------------
def send_telegram_message(message: str, chat_id: str = TELEGRAM_CHAT_ID):
    try:
        telegram_bot.send_message(chat_id=chat_id, text=message)
        print("Telegram message sent successfully.")
        return True
    except Exception as e:
        print(f"Failed to send Telegram message: {e}")
        return False

# --------------------------
# FIXED: Simplified negotiation prompt generation
# --------------------------
def generate_negotiation_prompt(product_name, current_price, suggested_price, competitor_data, tone):
    """Generate a simple, direct negotiation prompt that works with Portia"""
    
    tone_instructions = {
        "polite": "Write in a polite and professional tone",
        "friendly": "Write in a friendly and casual tone", 
        "assertive": "Write in an assertive but respectful tone"
    }
    
    instruction = tone_instructions.get(tone, "Write in a polite tone")
    
    # Simple, direct prompt that avoids schema issues
    prompt = f"""{instruction}.

Write a negotiation message for buying a {product_name}.
- Current listed price: ${current_price}
- Your target price: ${suggested_price}
- Be brief, respectful, and persuasive
- Include specific price mention
- End with a call to action

Just write the message, nothing else."""
    
    return prompt

# --------------------------
# FIXED: Robust message extraction with fallback
# --------------------------
def extract_message_from_response(response):
    """Extract negotiation message from Portia response with multiple fallbacks"""
    try:
        # Method 1: Direct string conversion (most reliable)
        message = str(response)
        
        # Clean up common Portia wrapper text
        if "value=" in message:
            # Try to extract just the message content
            lines = message.split('\n')
            clean_lines = []
            for line in lines:
                if not line.startswith(('DEBUG:', 'Response', 'Outputs', 'value=')):
                    clean_lines.append(line.strip())
            
            if clean_lines:
                message = '\n'.join(clean_lines)
        
        # Remove common debug prefixes
        message = message.replace("value='", "").replace("'", "").strip()
        
        # If message is too short or looks like debug output, use fallback
        if len(message) < 20 or "PlanRunOutputs" in message or "DEBUG:" in message:
            return None
            
        return message
        
    except Exception as e:
        print(f"Error extracting message: {e}")
        return None

# --------------------------
# FIXED: Fallback message generator
# --------------------------
def generate_fallback_message(product_name, current_price, final_price, tone):
    """Generate a fallback message if Portia fails"""
    
    if tone == "friendly":
        return f"""Hi there!

I'm really interested in your {product_name} that you have listed for ${current_price}. I've been looking around and doing some research on similar items. 

Would you consider ${final_price}? I'm ready to buy right away if we can work something out.

Let me know what you think!

Thanks!"""
    
    elif tone == "assertive":
        return f"""Hello,

I am interested in purchasing your {product_name} currently listed at ${current_price}. Based on my market research and comparable listings, I believe ${final_price} would be a fair price point.

I am prepared to complete this transaction immediately at this price. Please let me know if you would be willing to accept this offer.

Thank you for your consideration."""
    
    else:  # polite
        return f"""Dear Seller,

I hope this message finds you well. I am writing to express my interest in your {product_name} listed at ${current_price}.

After researching similar items, I was wondering if you might consider ${final_price}. I would very much appreciate the opportunity to complete this purchase at that price point.

Thank you for your time and consideration. I look forward to hearing from you.

Best regards"""

# --------------------------
# FIXED: Main flow with better error handling
# --------------------------
async def main():
    # Initialize MCP Email Client
    mcp_email_client = MCPEmailClient(MCP_EMAIL_SERVER_PATH)
    
    product_name = input("Product name: ")
    
    while True:
        try:
            current_price = float(input("Current price: "))
            break
        except ValueError:
            print("Please enter a valid number.")
            
    print("Fetching competitor prices...")
    competitor_prices = await scrape_ebay(product_name)
    print("Competitor prices:", competitor_prices)
    
    suggested_price = suggest_price(current_price, competitor_prices)
    print(f"Suggested negotiation price: ${suggested_price}")
    
    while True:
        try:
            final_price = float(input(f"Enter your desired price (or press enter to accept {suggested_price}): ") or suggested_price)
            break
        except ValueError:
            print("Please enter a valid number.")
    
    tone = input("Select tone [polite, friendly, assertive]: ").lower().strip()
    
    # Try Portia first, with fallback
    message = None
    try:
        print("Generating negotiation message with AI...")
        
        prompt = generate_negotiation_prompt(product_name, current_price, final_price, competitor_prices, tone)
        
        config = Config.from_default(
            llm_provider=LLMProvider.GOOGLE,
            default_model="google/gemini-2.0-flash",
            google_api_key=GOOGLE_API_KEY,
        )
        portia = Portia(config=config)
        
        negotiation_response = portia.run(prompt)
        message = extract_message_from_response(negotiation_response)
        
        if not message:
            raise Exception("Could not extract valid message from AI response")
            
    except Exception as e:
        print(f"AI generation failed ({e}), using fallback message...")
        message = generate_fallback_message(product_name, current_price, final_price, tone)
    
    print("\nNegotiation message:\n")
    print(message)
    
    approval = input("\nApprove message? (y/n): ").lower()
    while approval != 'y':
        feedback = input("Enter feedback for improving the message:\n")
        
        # Try to regenerate with feedback, fallback to manual editing
        try:
            new_prompt = generate_negotiation_prompt(product_name, current_price, final_price, competitor_prices, tone) + f"\n\nUser feedback: {feedback}. Please improve the message based on this feedback."
            config = Config.from_default(
                llm_provider=LLMProvider.GOOGLE,
                default_model="google/gemini-2.0-flash",
                google_api_key=GOOGLE_API_KEY,
            )
            portia = Portia(config=config)
            negotiation_response = portia.run(new_prompt)
            new_message = extract_message_from_response(negotiation_response)
            
            if new_message:
                message = new_message
            else:
                print("AI couldn't improve the message. Please edit it manually if needed.")
                
        except Exception as e:
            print(f"Could not regenerate message: {e}")
            print("Please manually edit if needed.")
        
        print("\nUpdated message:\n")
        print(message)
        approval = input("\nApprove this message? (y/n): ").lower()
    
    # Choose sending method
    send_method = input("\nSend via [telegram/email/both]: ").lower().strip()
    
    if send_method in ['telegram', 'both']:
        if send_telegram_message(message):
            print("\nNegotiation message sent via Telegram. Check your chat!")
        else:
            print("\nFailed to send via Telegram.")
    
    if send_method in ['email', 'both']:
        recipient = input("Enter recipient email address: ").strip()
        subject = f"Price Negotiation Request for {product_name}"
        
        print("\nSending message via MCP Email Server...")
        if await mcp_email_client.send_email_via_mcp(recipient, subject, message):
            print(f"Negotiation message sent via email to {recipient}!")
        else:
            print("Failed to send via email.")
    
    if send_method not in ['telegram', 'email', 'both']:
        print("\nYou can copy the message manually:")
        print("-" * 40)
        print(message)
        print("-" * 40)
    
    print("Negotiation Complete.")

if __name__ == "__main__":
    asyncio.run(main())


